#summary User guide
#labels Featured

<wiki:toc max_depth="2"/>

= How to use? =

At the heart of Coroutine library lies Java agent that performs bytecode instrumentation providing coroutine semantics support. This agent, along with all needed classes, is located in  *coroutines.jar*. To use coroutines in your project you need to tell JVM to use the agent. This is done by passing following option to JVM:
  `-javaagent:<path to coroutines.jar>=[agent options]`
, where _agent options_ are either:
  `runtime[-options]` (1)
or:
  `<classname>[-options](;<classname>[-options])*[;-options]` (2)

The former form (1) tells coroutine agent to look for classes using coroutines during classloading. The latter form (2) specifies list of classes for which you need coroutine support explicitly, so lookup is not needed. This is slightly faster, so if you are concerned with class loading speed use this form.

== Options ==

Options modify the behavior of agent. All options, as seen above, are preceded by '-' character. If you use form (2) options after all class names  (after the last ';') are considered global (applied for all classes), and options after a class name are in effect only for the preceding class. Possible options are (separated by ','):
  * debug: turns on debugging code generation. Debugging code provides logging coroutine execution state on coroutine entry and exit (state of local variables and stack, along with local variable names if code contains debugging information and line of code where execution is supsended),
  * print: prints generated bytecode for instrumented class to a file. This file is created under directory passed in mr.go.coroutines.PrintPath system property (default is current directory). Directory chain representing class packaging is created, file is named after instrumented class with .trace extension (bytecode for com.acme.MyClass can be found at com/acme/MyClass.trace in PrintPath),
  * outputbin: outputs instrumented class file in JVM class file format. The class file is created under directory passed in mr.go.coroutines.ClassgenPath system property (default is current directory).  Directory chain representing class packaging is created, file is named after instrumented class + 'Instrumented' with  standard .class extension (classfile for com.acme.MyClass can be found at com/acme/MyClassInstrumented.class in ClassgenPath),
  * preverify: (advanced) uses ASM verifier in process of instrumenting. Used for debugging only,
  * postverify: (advanced) verifies whole instrumented class after instrumentation. Used for debugging only,
  * overrideframes: "last chance option" - sometimes it happens that instrumented code is not passing Java verification stage. This has almost always been result of a bug in the Coroutine library. While you are encouraged to file a bug in such case, you may need to get something done quickly without waiting for this bug to be fixed. Sometimes specifying this option helps (mostly if generated code has inconsistent stack map tables)

== Dependencies ==

For agent to work you need following libraries on your classpath:
  * _commons-collections_ (commons-collections-3.2.1.jar is included in this library),
  * _asm_ (asm-3.2.jar, asm-commons-3.2.jar are always needed and are included, if you are needing to debug Coroutines down to asm level you may use asm-debug-all-3.2.jar instead, which is also included. If you happen to use: print - then you will need additionally asm-util-3.2.jar; preverify or postverify - asm-util-3.2.jar, asm-analysis-3.2.ajr, asm-tree-3.2.jar - all included)

To write any coroutine you also need coroutine user library (coroutines_user_xxx.jar) to be found on classpath.

To use generated coroutines some run-time generated classes are also needed. All such classes are created on disk under directory passed in mr.go.coroutines.ClassgenPath system property. You must have this directory in your classpath also. 

== Java version ==

Coroutines are meant to work only for Java 6 code. No plans to support earlier versions are made (this is mainly due to disallowance of _jsr_ and _ret_ instructions and stack map tables). All instrumentation made by this library have to be pass new class verification (you may safely use -XX:-FailOverToOldVerifier) as outlined in JSR-202

== Logging ==

This library uses JDK logging in following fashion: 
  * informational messages about instrumentation process are logged by mr.go.coroutines.ClassTransformer, mr.go.coroutines.CoroutineInstrumentator and mr.go.coroutines.ClassAnalyzer loggers - mostly FINEST and FINER levels, these loggers are also used for reporting warnings if instrumentation cannot be, for some reason, completed - WARNING level, if unexpected exception was thrown when instrumenting, also SEVERE
  * if _debug_ option is specified additional loggers are used to trace coroutine execution, one per instrumented class. Tracing logger is named after fully qualified name of instrumented class. All information about coroutine state is logged on FINER and FINEST levels