#summary User guide
#labels Featured

<wiki:toc max_depth="2"/>

= How to use? =

At the heart of Coroutine library lies Java agent that performs bytecode instrumentation providing coroutine semantics support. This agent, along with all needed classes, is located in  *coroutines.jar*. To use coroutines in your project you need to tell JVM to use that agent. This is done by passing following option to JVM:
  `-javaagent:<path to coroutines.jar>=[agent options]`
, where _agent options_ are either:
  `runtime[-options]` (1)
or:
  `<classname>[-options](;<classname>[-options])*[;-options]` (2)

The former (1) tells coroutine agent to look for classes with coroutines during class loading. The latter form (2) specifies a list of classes for which you need coroutine support, explicitly, so lookup is not needed. This is slightly faster so if you are concerned with class loading speed use this form.

== Options ==

All options are preceded by '-' character. If you use (2) options after all class names  (that is, after the last ';') are considered global (applied for all classes) while options after a class name are in effect only for preceding class. Possible options are (separated by ','):
  * debug: turns on debugging code generation. Debugging code provides logging coroutine execution state on coroutine entry and exit (values of local variables and stack operands along with local variable names and line of code where execution has been suspended if code contains debugging information ),
  * print: prints generated bytecode for instrumented class to file. File is created in directory passed in `mr.go.coroutines.PrintPath` system property (default is current directory). Directory chain representing class packaging is created. File name is instrumented class simple name with .trace extension (bytecode for `com.acme.MyClass` can be found at `com/acme/MyClass.trace` in `PrintPath`),
  * outputbin: outputs instrumented class file in the JVM class file format. The class file is created in directory passed in `mr.go.coroutines.ClassgenPath` system property (default is current directory).  Directory chain representing class packaging is created. File is named after instrumented class + 'Instrumented' with  standard .class extension appended (classfile for `com.acme.MyClass` can be found at `com/acme/MyClassInstrumented.class` in `ClassgenPath`),
  * preverify: (advanced) uses ASM verifier in process of instrumenting. Used for debugging only,
  * postverify: (advanced) verifies whole instrumented class after instrumentation. Used for debugging only,
  * overrideframes: "last chance option" - sometimes it happens that instrumented code is not passing Java verification stage because of applied instrumentation. This has almost always been result of a bug in the Coroutine library. While you are encouraged to file a bug in such case, you may need to get something done quickly without waiting for this to be fixed. Sometimes specifying `overrideframes` helps and code passes verification (mostly if generated code has inconsistent stack map tables). See [Internals#Stack_map_table] for detailed information of what this switch does.

== Examples ==

  `javaagent:coroutines.jar=com.acme.MyClass1;com.acme.MyClass2`

Instruments two classes

  `javaagent:coroutines.jar=com.acme.MyClass1;com.acme.MyClass2;-outputbin`

Instruments two classes and outputs instrumented code as class files.

  `javaagent:coroutines.jar=com.acme.MyClass1-debug;com.acme.MyClass2;-outputbin`

Instruments two classes and outputs instrumented code as class files and additionally generates debug version of `com.acme.MyClass1`

  `javaagent:coroutines.jar=runtime-outputbin`

Determines which classes need to be instrumented during loading. If class has been instrumented generated bytecode is written to disk

 Since v1_1 you can use `mr.go.coroutines.DefaultPackage` system property to tell the  agent to look for the classes in the specified package in addition - that may save some typying

== Dependencies ==

For agent to work you need following libraries on your classpath:
  * _commons-collections_ (commons-collections-3.2.1.jar is included in this library),
  * _asm_ (asm-3.2.jar, asm-commons-3.2.jar are always needed and are included, if you need to debug Coroutines down to asm level you may use asm-debug-all-3.2.jar instead which is also included. If you happen to use options like: print - then you will need additionally asm-util-3.2.jar; preverify or postverify - asm-util-3.2.jar, asm-analysis-3.2.ajr, asm-tree-3.2.jar - all included)

  Since v1_1 only asm-all.jar is included

To write any coroutine you also need coroutine user library (*coroutines_user_xxx.jar*) to be found on classpath.

To use generated coroutines some run-time generated classes are also needed. All such classes are written on disk in directory passed in `mr.go.coroutines.ClassgenPath` system property. You must have this directory in your classpath also. 

== Java version ==

Coroutines are meant to work only with Java 6 code. No plans to support earlier versions are made (this is mainly due to disallowance of _jsr_ and _ret_ instructions and stack map tables). All instrumentations made by this library have to pass new class verification (you may safely use `-XX:-FailOverToOldVerifier`) as outlined in JSR-202

== Logging ==

This library uses JDK logging in the following fashion: 
  * informational messages about instrumentation process are logged by `mr.go.coroutines.ClassTransformer`, `mr.go.coroutines.CoroutineInstrumentator` and `mr.go.coroutines.ClassAnalyzer` loggers - FINEST and FINER levels. These loggers are also used for reporting warnings if instrumentation cannot be, for some reason, completed - WARNING level, or if unexpected exception was thrown when instrumenting - SEVERE
  * if _debug_ option is specified additional loggers are used to trace coroutine execution. There is one logger per instrumented class and it is named after fully qualified name of the instrumented class. All information about coroutine state is logged on FINER and FINEST levels

== Compilers ==

Currently, this library has been tested with two Java 6 compilers:
  * javac
  * Eclipse compiler
While it should be compatible with bytecode produced by any conforming Java 6 compiler, its compatibility with other compilers has not been proven. Please report any compatibility issues (or lack of them) with other compilers as you notice them. 

= How to write? =

Writing coroutines is not much different than writing any ordinary Java method. There are only two special methods you need to keep in mind - _yield_ and _ `_ method` _. They are defined in _mr.go.coroutines.user.Coroutines_. You are strongly recommended to static import them for aesthetic verbosity. If you browse their source, you'll notice that they are strange one-liners that do not do much apart from throwing an exception. That's right - but they are known to Java agent which transforms them into something more useful. Let's then write some example coroutine and try to understand what it is all about. This example is modeled after David Beazley's example for Python - in fact, this library aims to be on a par with Python coroutines. You can see the original example [http://www.dabeaz.com/coroutines/Coroutines.pdf here]

{{{
import static mr.go.coroutines.user.Coroutines._;
import static mr.go.coroutines.user.Coroutines.yield;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.regex.Pattern;

import mr.go.coroutines.user.CoIterator;
import mr.go.coroutines.user.Coroutine;
import mr.go.coroutines.user.CoroutineExitException;

public final class Grep {

	@Coroutine
	public static CoIterator<String, Void> grep(String pattern, String file)
			throws IOException {
		FileReader freader = new FileReader(file);
		BufferedReader reader = new BufferedReader(freader);
		String line;
		Pattern regex = Pattern.compile(pattern);
		try {
			while ((line = reader.readLine()) != null) {
				boolean isFound = regex.matcher(line).find();
				if (isFound) {
					yield(line);
				}
			}
		} catch (CoroutineExitException e) {
			reader.close();
			throw e;
		}
		yield(null);
		reader.close();
		return _();
	}
}
}}}

We will follow this (and others) example in subsequent sections of this document

== Definition of coroutine method ==

First, and probably the most important thing to remember is to annotate every coroutine method with `mr.go.coroutines.user.Coroutine` annotation. `Coroutine` annotation may be used as in the example, but there are also two additional options that control Coroutine behavior. They are explained in [#Coroutine_annotation] section. 

Coroutine methods may be private, public, protected, static - there are no restrictions whatsoever, only the class containing a coroutine must be visible to all classes outside its package which simply means that it has to be public. Second requirement for a method which you want to be coroutine concerns type of its result. It has to be `mr.go.coroutines.user.CoIterator`. If it is not then warning is logged and class is not instrumented which will probably manifest itself with `InvalidCoroutineException` or even something worse (as nonterminating loop) during program run. There are two important things about `CoIterator`: it is an interface which contains coroutine execution state and provides clients of coroutine with the ability to control coroutine behavior (like obtaining result from coroutine and sending values to coroutine), and, you do not have to implement this interface ever because it is dynamically implemented by instrumentation layer. 

There are no other obligations for coroutine author - method can throw any exceptions, contain any valid Java code, take arbitrary arguments etc (actually there is one more, governing where _yield_ can be used: it must not be used as an argument to a constructor. But more on this later). `CoIterator` is generic type which takes two type arguments - first indicates type of result coroutine produces (in grep case it is String), second tells what coroutine expects to be sent (grep clearly does not need to be sent anything to do its job, thus Void). 

== Execution of coroutine ==

Coroutine executes as any Java method until it encounters _yield_ method. _yield_ does not execute as regular method, if it had, it would throw `InvalidCoroutineException`. Instead of throwing exception (which indicates that coroutine has not been properly instrumented) _yield_ saves current execution context - local variables and operand stack - at the point of _yield_ and makes method return to its caller. Saving stack is necessary because _yield_ can be part of some bigger expression, consider: {{{threshold = threshold - delta * (Double) yield(rnd < threshold);}}} Argument of _yield_ becomes now the current result of coroutine (that is, the result of `CoIterator` _next_ as `CoIterator` is normally one and only coroutine caller. But there is no need to be aware of `CoIterator`'s role in this process from coroutine author's point of view as `CoIterator` is simply the interface of coroutine to its clients, thus by saying 'caller' we mean `CoIterator` _next_ or _send_ caller). Additionally, you may use _yield_ overload which takes no arguments, caller is then passed `null`. It is mainly useful when you want to receive something from the caller, rather than send him something. In the example, we want to pass matching line from a file, so we are using the former _yield_ form. We also do not expect anything to be sent to us, so there is no need to assign _yield_ to anything.

Coroutine remains suspended until its caller wants to obtain next result, or decides to send something to coroutine. Execution is then resumed from the point of last executed _yield_. Local variables and stack are restored. If caller sent a value then it becomes the result of _yield_ and execution continues normally. Looking at grep code you will notice that it immediately tries to read next line from file in an effort to find next matching line.
There are only two exceptions to this execution flow. The first is when coroutine decides that it has nothing more to do, like grep when nothing more can be read from file, and it leaves its inner loop. Grep tries to inform its caller about encountered state and yields `null`. If caller, after it has received this `null`, erroneously calls grep one more time then grep will execute the _ `_ method` _ . The result of this method would have normally been passed to caller, but this is not the case - it would have been indistinguishable from _yield_. Instead of normal execution the _ `_ method` _ results in `NoSuchElementException` being thrown to the caller (this exception has been chosen to make coroutines similar to standard Java iterators). The second exception occurs when caller decides that it does not need to call coroutine anymore and, through `CoIterator`, it issues _close_ command which results in throwing `CoroutineExitException` from _yield_. You can catch this exception if you want and react correspondingly (grep closes opened stream in this case), you may ignore it completely as well - this exception is never thrown back to the caller. If you try to _yield_ from `CoroutineExitException` handler, you will silently fail. Caller never receives anything from your coroutine at this point of execution. Therefore, there are two actual ways of dealing with _close_ - to ignore it, or to clean up and exit.

== Return statements ==

Coroutines very often _yield_ from some form of never-ending loop. The most classical example being Fibonacci numbers generator (generators can be written using coroutines, generator is simply a coroutine which never expects anything from its caller - like grep)
{{{
	@Coroutine
	public static CoIterator<Integer, Void> fibonacciNumbers() {
		int a = 0;
		int b = 1;
		while (true) {
			yield(a);
			int next = a + b;
			a = b;
			b = next;
		}
	}
}}}

In such cases it is up to the caller to _close_ coroutine, as coroutine by itself can execute endlessly. But what is maybe more important than caller considerations, is the fact that most (all?) Java compilers do not enforce that such method contains return statement. They are content with information obtained from static analysis that such code will execute forever. But there are numerous examples when coroutine has to return. Take grep - it obviously produces only finite stream of results. Java compiler will not accept such method without return statement. Being forced to return an instance of `CoIterator` interface, which has no user-visible implementations and it is quite impossible to provide one without overdoing this library's work, you are left with only two real choices - to return `null` or to throw an exception. Either choice will inevitably end up in somehow awkward-looking code. To fix that special _ `_ method` _ has been introduced. You are not forced to use it in any way. In fact ALL return statements in your code are transformed under the hood into `NoSuchElementException` so it does not really mater which option you will choose. But I found that it is convenient to have such 'special' method to indicate coroutine exit (instrumentation basically changes all occurrences of _ `_ method` _ to no-op)

== Coroutine annotation ==

Coroutine annotation has two flags.

The first is `generator` flag. By default it is set to be true. If set to false the annotated coroutine is executed before `CoIterator` is returned to its caller. This has the obvious effect of suspending execution at the first encountered _yield_ (as if caller executed _next_). It may come handy when coroutine does not generate anything (at least not on its first call), but rather waits for caller to _send_ something in. Consider famous telegram receiver problem, which is considered to be a showcase for coroutines (taken from [http://www.amazon.com/Coroutines-Programming-Methodology-Implementation-ebook/dp/B0014D4QVQ Coroutines: A Programming Methodology, a Language Design and an Implementation] by Christopher Marlin, you can find this example in [http://books.google.com/books?id=bIAxhJor1EYC&pg=PP1#v=onepage&q=&f=false Google Books edition], page 14). Brief: write a program which processes stream of telegraphs. Telegraph consists of words terminated by STOP. If program receives ZZZZZ then telegraph has ended. EOT occurs when empty telegraph arrives. Upon end program must print summary report of all received telegraphs containing: text of telegraph, number of chargeable words (all words except ZZZZZ and STOP are chargeable) and flag signaling over-length words (length of word > 12). Simple solution will use coroutine for state machine part of problem and some external feed for incoming strings. We might write following solution
{{{
	@Coroutine(generator = false)
	public CoIterator<Void, String> receiver(List<Telegram> telegrams) {
		Telegram t;
		int wordCount = 0;
		boolean hasOverlengthWord = false;
		StringBuilder msg = new StringBuilder();
		while (true) {
			String part = yield();
			if (part.equals(DELIMITER)) {
				if (wordCount == 0) {
					return _();
				}
				t = new Telegram(msg.toString(), wordCount, hasOverlengthWord);
				telegrams.add(t);
				msg = new StringBuilder();
				wordCount = 0;
				hasOverlengthWord = false;
			} else if (part.equals("STOP")) {
				msg.append(' ');
			} else {
				if (part.length() > maxLength) {
					hasOverlengthWord = true;
					part = part.substring(0, 11);
				}
				wordCount += 1;
				msg.append(part);
			}
		}
	}
}}}
We could live without `generator` flag, but then our feed component would be required to call _next_ before _send_ just to execute coroutine up to the _yield_ so that it can be resumed with sent value. `Generator` flag can be set to false to eliminate such calls from user code. It automatically calls _next_ by itself so caller does not need to bother and may start sending values right away. As the name of the flag indicates, you should not generate anything useful on the first call as that value is effectively lost.

The second flag is `threadLocal` flag. This flag indicated that one `CoIterator` will be reused by many threads. Each thread then receives its own coroutine state and they can freely reuse coroutine without worrying about state inconsistencies. Without this flag set you should never share any `CoIterator` instance between many threads, also there exists no way to share `CoIterator` between threads which shares coroutine execution state. Threads should not be mixed with coroutines.

== What not to do? ==

You cannot use _yield_ as an argument to constructor. Due to the JVM mechanisms of object creation and initialization _yield_ would have to save yet uninitialized (because constructor did not have a chance to run) chunk of memory and restore it later, which is not possible. If you did that, the instrumentation throws `CoroutineGenerationException` with appropriate message.
That rule has a slightly surprising consequence: you cannot use _yield_ as the first string while concatenating strings using '+' operator. This restriction follows from the very same 'constructor rule': string concatenation under the hood is nothing more than creation of `StringBuilder` and calling append on it. When you write {{{String s = a + 'b' + c;}}} it is compiled to {{{String s = new StringBuilder(a).append('b').append(c).toString(); }}} therefore, as you probably have already noticed, if you substituted _yield_ for `a` you would break 'constructor rule'.

= How to use THEM? =

You need to obtain `CoIterator` for any coroutine you want to use. As every coroutine returns `CoIterator` instance you just have to call the method. Going back to the grep example you'd write
{{{
	String file = "lines.txt";
	CoIterator<String, Void> lines = Grep.grep("Java", file);
}}}
Values that are being produced by coroutine can be retrieved using _next_ method. So to see all lines containg word 'Java' in `lines.txt` you just call _next_ method repeatedly until you receive `null`, which grep produces to indicate EOF, or, in general case, `NoSuchElementException` is thrown
{{{
String foundLine = lines.next();
}}}
Coroutine may throw any other exception which it declares in its `throws` clause or is an unchecked exception. If such exception is thrown it can be caught at _next_.

If you want to terminate coroutine before it finishes by itself you call _close_ method
{{{
lines.close();
}}}
After coroutine has been closed you must obtain new `CoIterator` instance - any call to the closed one results in `CoroutineClosedException`

If communication with coroutine is bidirectional you should use _send_ method. Consider telegraph receiver coroutine from previous section. Programming that coroutine may look like
{{{
		TelegramReceiver tg = new TelegramReceiver();
		List<Telegram> telegrams = new LinkedList<Telegram>();
		CoIterator<Void, String> telegramStream = tg.receiver(telegrams);
		telegramStream.send("Hello");
		telegramStream.send("STOP");
		telegramStream.send("How");
...
}}}
If coroutine yields a value it becomes the result of _send_

== Coroutine as Iterable ==

More often than not a need arises to use coroutine results as target of enhanced for loop. Let's take binary tree iterator
{{{
	@Coroutine
	private CoIterator<T, Void> inorder(TreeNode t) {
		if (t != null) {
			for (T x : inorder(t.left).each()) {
				yield(x);
			}
			yield(t.key);
			for (T x : inorder(t.right).each()) {
				yield(x);
			}
		}
		return _();
	}

	public Iterable<T> inorder() {
		return inorder(root).each();
	}
}}}
You can transform `CoIterator` to `Iterable` using _each_. _each_ captures `NoSuchElementException` and `CoroutineClosedException` (you can _close_ underlying `CoIterator` during iteration) so it knows when to 'terminate' itself.
Obvious deficiency of this method is that it cannot work with forever-looping coroutines. If you used Fibonacci generator's _each_ with enhanced for, you'd end up with unterminated loop and your only way out would be to _close_ `CoIterator`. In such cases it is advisable to use _till_. _till_ finishes iteration based on a exit condition e.g. last returned value or number of returned values
{{{
		for (int fib : NumberGenerator.fibonacciNumbers().till(13)) {
...
		}
}}}
Here you ask generator to generate only the first 13 Fibonacci numbers.

Sometimes you might prefer to work with standard Java iterator instead. For example, let's check whether two binary trees have exactly the same leaves
{{{
	@Coroutine
	private CoIterator<T, Void> leaves(TreeNode t) {
		if (t.isLeaf()) {
			yield(t.key);
		} else {
			if (t.left != null) {
				for (T x : leaves(t.left).each()) {
					yield(x);
				}
			}
			if (t.right != null) {
				for (T x : leaves(t.right).each()) {
					yield(x);
				}
			}
		}
		return _();
	}

	public static <T extends Comparable<T>> boolean sameFringe(
			Tree<T> t1,
			Tree<T> t2) {
		Iterator<T> t1Leaves = t1.leaves(t1.root).each().iterator();
		Iterator<T> t2Leaves = t2.leaves(t2.root).each().iterator();

		while (t1Leaves.hasNext() && t2Leaves.hasNext()) {
			if (t1Leaves.next().compareTo(t2Leaves.next()) != 0) {
				return false;
			}
		}
		return !t1Leaves.hasNext() && !t2Leaves.hasNext();
	}
}}}