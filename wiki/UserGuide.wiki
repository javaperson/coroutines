#summary User guide
#labels Featured

<wiki:toc max_depth="2"/>

= How to use? =

At the heart of Coroutine library lies Java agent that performs bytecode instrumentation providing coroutine semantics support. This agent, along with all needed classes, is located in  *coroutines.jar*. To use coroutines in your project you need to tell JVM to use the agent. This is done by passing following option to JVM:
  `-javaagent:<path to coroutines.jar>=[agent options]`
, where _agent options_ are either:
  `runtime[-options]` (1)
or:
  `<classname>[-options](;<classname>[-options])*[;-options]` (2)

The former form (1) tells coroutine agent to look for classes using coroutines during classloading. The latter form (2) specifies list of classes for which you need coroutine support explicitly, so lookup is not needed. This is slightly faster, so if you are concerned with class loading speed use this form.

== Options ==

Options modify the behavior of agent. All options, as seen above, are preceded by '-' character. If you use form (2) options after all class names  (after the last ';') are considered global (applied for all classes), and options after a class name are in effect only for the preceding class. Possible options are (separated by ','):
  * debug: turns on debugging code generation. Debugging code provides logging coroutine execution state on coroutine entry and exit (state of local variables and stack, along with local variable names if code contains debugging information and line of code where execution is supsended),
  * print: prints generated bytecode for instrumented class to a file. This file is created under directory passed in `mr.go.coroutines.PrintPath` system property (default is current directory). Directory chain representing class packaging is created, file is named after instrumented class with .trace extension (bytecode for `com.acme.MyClass` can be found at `com/acme/MyClass.trace` in `PrintPath`),
  * outputbin: outputs instrumented class file in JVM class file format. The class file is created under directory passed in `mr.go.coroutines.ClassgenPath` system property (default is current directory).  Directory chain representing class packaging is created, file is named after instrumented class + 'Instrumented' with  standard .class extension (classfile for `com.acme.MyClass` can be found at `com/acme/MyClassInstrumented.class` in `ClassgenPath`),
  * preverify: (advanced) uses ASM verifier in process of instrumenting. Used for debugging only,
  * postverify: (advanced) verifies whole instrumented class after instrumentation. Used for debugging only,
  * overrideframes: "last chance option" - sometimes it happens that instrumented code is not passing Java verification stage. This has almost always been result of a bug in the Coroutine library. While you are encouraged to file a bug in such case, you may need to get something done quickly without waiting for this bug to be fixed. Sometimes specifying this option helps (mostly if generated code has inconsistent stack map tables)

== Dependencies ==

For agent to work you need following libraries on your classpath:
  * _commons-collections_ (commons-collections-3.2.1.jar is included in this library),
  * _asm_ (asm-3.2.jar, asm-commons-3.2.jar are always needed and are included, if you are needing to debug Coroutines down to asm level you may use asm-debug-all-3.2.jar instead, which is also included. If you happen to use: print - then you will need additionally asm-util-3.2.jar; preverify or postverify - asm-util-3.2.jar, asm-analysis-3.2.ajr, asm-tree-3.2.jar - all included)

To write any coroutine you also need coroutine user library (coroutines_user_xxx.jar) to be found on classpath.

To use generated coroutines some run-time generated classes are also needed. All such classes are created on disk under directory passed in `mr.go.coroutines.ClassgenPath` system property. You must have this directory in your classpath also. 

== Java version ==

Coroutines are meant to work only for Java 6 code. No plans to support earlier versions are made (this is mainly due to disallowance of _jsr_ and _ret_ instructions and stack map tables). All instrumentation made by this library have to be pass new class verification (you may safely use -XX:-FailOverToOldVerifier) as outlined in JSR-202

== Logging ==

This library uses JDK logging in following fashion: 
  * informational messages about instrumentation process are logged by `mr.go.coroutines.ClassTransformer`, `mr.go.coroutines.CoroutineInstrumentator` and `mr.go.coroutines.ClassAnalyzer` loggers - mostly FINEST and FINER levels, these loggers are also used for reporting warnings if instrumentation cannot be, for some reason, completed - WARNING level, if unexpected exception was thrown when instrumenting, also SEVERE
  * if _debug_ option is specified additional loggers are used to trace coroutine execution, one per instrumented class. Tracing logger is named after fully qualified name of instrumented class. All information about coroutine state is logged on FINER and FINEST levels

== Compilers ==

Currently, this library has been tested with two Java 6 compilers:
  * javac
  * Eclipse compiler
While it should be compatible with code produced by any conforming Java 6 compiler, its compatibility has not been proven. Please report any compatibility issues (or lack of them) with other compilers as you notice them. 

= How to write? =

Writing coroutines is not much different than writing ordinary Java method. There are only two special methods you need to remember about - _yield_ and _ `_ method` _. They are defined in _mr.go.coroutines.user.Coroutines_, you are strongly recommended to static import them for aesthetic verbosity. If you browse their source, you'll notice that they are strange one-liners that do not do much apart from throwing an exception. That's right - but they are known to Java agent which transforms them into something useful. Let's then write some example coroutine and try to understand what is it all about. This example is modeled after David Beazley's example for Python - in fact, this library aims to be on a par with Python coroutines. You can see the original example [http://www.dabeaz.com/coroutines/Coroutines.pdf here]

{{{
import static mr.go.coroutines.user.Coroutines._;
import static mr.go.coroutines.user.Coroutines.yield;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.regex.Pattern;

import mr.go.coroutines.user.CoIterator;
import mr.go.coroutines.user.Coroutine;
import mr.go.coroutines.user.CoroutineExitException;

public final class Grep {

	@Coroutine
	public static CoIterator<String, Void> grep(String pattern, String file)
			throws IOException {
		FileReader freader = new FileReader(file);
		BufferedReader reader = new BufferedReader(freader);
		String line;
		Pattern regex = Pattern.compile(pattern);
		try {
			while ((line = reader.readLine()) != null) {
				boolean isFound = regex.matcher(line).find();
				if (isFound) {
					yield(line);
				}
			}
		} catch (CoroutineExitException e) {
			reader.close();
			throw e;
		}
		yield(null);
		reader.close();
		return _();
	}
}
}}}

We will follow this (and others) example in subsequent sections of this document

== Definition of coroutine method ==

First, and probably the most important, thing to remember is to annotate every coroutine method with Coroutine annotation. The annotation may be used as in the example, but there are also two other options which control Coroutine behavior. They are explained in [#Coroutine_annotation] section. Coroutine methods may be private, public, protected, static - there are no restrictions whatsoever. Only the class containing a coroutine must be visible to classes outside its package, which simply means that it has to be public. Second requirement for method which you want to be coroutine concerns type of its result. It has to be `mr.go.coroutines.user.CoIterator`. If it is not then warning is logged and class is left not instrumented, which will probably manifest itself with `InvalidCoroutineException` or even something worse (as nonterminating loop). Two important things about `CoIterator`: it is interface which contains coroutine execution state and provides clients of coroutine with ability to control its behavior (like obtaining result from coroutine and sending values to coroutine), and, you do not have to implement this interface ever. It is always implemented by instrumentation layer. There are no other obligations for coroutine author - method can throw any exceptions, contain any valid Java code, take arbitrary arguments etc (actually there is one more, governing where _yield_ can be used, it must not be used as an argument to a constructor. But more on this later). `CoIterator` is generic type which takes two type arguments - first indicates type of result coroutine produces (in grep case it is clearly a String), second - what it expects to be sent to it (grep clearly does not need to be sent anything to do its job, thus Void). 

== Execution of coroutine ==

Coroutine executes as any Java method until it encounters _yield_ method. _yield_ does not execute as normal method, if it had, it would throw `InvalidCoroutineException`. Instead of throwing exception (which indicates that coroutine has not been properly instrumented) _yield_ saves current execution context - that is: local variables and operand stack at this point and makes method return to its caller. Saving stack is necessary when _yield_ is part of some bigger expression, consider: {{{threshold = threshold - delta * (Double) yield(rnd < threshold);}}} Argument of _yield_ becomes now the current result of coroutine (that is, the result of `CoIterator` _next_ as `CoIterator` is normally the only coroutine caller, but there is no need to be aware of `CoIterator`'s role in this process from coroutine author's point of view, as `CoIterator` is simply an interface of coroutine to its clients, thus by saying 'caller' we mean `CoIterator` _next_ or _send_ caller). Additionally, you may use _yield_ overload which takes no arguments, then caller is simply passed `null`. It is mainly useful when you want to receive something from the caller, rather than send him something. In the example we want to pass line in a file matching a pattern, so we use appropriate _yield_ form. We also do not expect anything to be send to us, so we do not assign _yield_ to anything.

Coroutine remains suspended until its caller wants to obtain a next result, or sends something to coroutine. Execution is then resumed from the last executed _yield_. Local variables and stack are restored. If caller sent a value then it becomes the result of _yield_ and execution continues. Looking at grep you will notice that it immediately tries to read next line from file in an effort to find next matching line.
There are only two exceptions to this execution flow. The first is when coroutine decides that it has nothing to be done, like grep when nothing is to be read from file and it leaves its inner loop. Grep tries to inform its caller about this state and yields `null`. If caller, after it has received this `null`, erroneously calls coroutine one more time then you can see that coroutines executes the _ `_ method` _ . The result of this method would have normally been passed to caller, but this is not the case - it would have been indistinguishable from _yield_. Instead of normal execution the _ `_ method` _ results in `NoSuchElementException` thrown to caller (this execption has been chosen so that it makes coroutines similar to standard Java iterators). The second exception occurs when caller decides that it does not need coroutine anymore. Through `CoIterator` it issues _close_ command which results in throwing `CoroutineExitException` from _yield_. You can catch this exception if you want and react correspondingly (grep closes opened stream in this case), you may ignore it completely as well - this exception is never thrown to caller. If you try to _yield_ from `CoroutineExitException` handler, you will silently fail. Caller never receives anything from your coroutine at this point. Therefore, there are two actual ways of dealing with _close_ - to ignore it, or to clean up.

== Return statements ==

Coroutines very often _yield_ from some form of never-ending loop. The most classical example being Fibonacci numbers generator (generators can be written using coroutines, generator is simply a coroutine which never expects anything from its caller - like grep)
{{{
	@Coroutine
	public static CoIterator<Integer, Void> fibonacciNumbers() {
		int a = 0;
		int b = 1;
		while (true) {
			yield(a);
			int next = a + b;
			a = b;
			b = next;
		}
	}
}}}

In such cases it is up to the caller to _close_ coroutine, as coroutine by itself can execute endlessly. But what is maybe more important than caller considerations, is the fact that most (all?) Java compilers do not enforce that such method must contain return statement in such cases, being content with information, obtained from static analysis, that this code will execute forever. But there are numerous examples when coroutine in fact returns. Take grep - it obviously produces finite stream of results. Java compiler will not accept such method without return statement. Being forced to return an instance of `CoIterator` interface, which has no user-visible implementations and it is quite impossible to provide one without overdoing this library's work, you are left with only two real choices - to return `null` or to throw an exception. Either choice will inevitably end up in somehow awkward-looking code. To fix that special _ `_ method` _ has been introduced. You are not forced to use it in any way. In fact ALL return statements in your code are transformed under the hood into `NoSuchElementException` so it does not really mater which option you will choose. But I found that it is convenient to have such 'special' method to indicate coroutine exit (instrumentation basically changes all occurrences of _ `_ method` _ to kind of no-op)

== Coroutine annotation ==

Coroutine annotation has two flags.

The first is `generator` flag. By default it is set to be true. If set to false the annotated coroutine is executed before `CoIterator` is returned to its caller. This has the obvious effect of resuming execution on first encountered _yield_ (as if caller executed _next_). It may come handy when coroutine does not generate anything (at least on its first call), but rather waits for caller to _send_ something. Consider famous telegram receiver problem, which is considered to be a showcase for coroutines (taken from [http://www.amazon.com/Coroutines-Programming-Methodology-Implementation-ebook/dp/B0014D4QVQ Coroutines: A Programming Methodology, a Language Design and an Implementation] by Christopher Marlin, you can find this example in [http://books.google.com/books?id=bIAxhJor1EYC&pg=PP1#v=onepage&q=&f=false Google Books edition], page 14). Brief: write a program which processes stream of telegraphs, consisting of words terminated by STOP. If you receive ZZZZZ then telegraph has ended. EOT is on empty telegraph (with no words). Upon end print summary report of received telegraphs containing: text of telegraph, number of chargeable words (all words except ZZZZZ and STOP are chargeable), flag signaling over-length words (length of word > 12). Simple solution will use coroutine for state machine part of problem and some external feed of incoming strings. We might write following solution
{{{
	@Coroutine(generator = false)
	public CoIterator<Void, String> receiver(List<Telegram> telegrams) {
		Telegram t;
		int wordCount = 0;
		boolean hasOverlengthWord = false;
		StringBuilder msg = new StringBuilder();
		while (true) {
			String part = yield();
			if (part.equals(DELIMITER)) {
				if (wordCount == 0) {
					return _();
				}
				t = new Telegram(msg.toString(), wordCount, hasOverlengthWord);
				telegrams.add(t);
				msg = new StringBuilder();
				wordCount = 0;
				hasOverlengthWord = false;
			} else if (part.equals("STOP")) {
				msg.append(' ');
			} else {
				if (part.length() > maxLength) {
					hasOverlengthWord = true;
					part = part.substring(0, 11);
				}
				wordCount += 1;
				msg.append(part);
			}
		}
	}
}}}
We could live without `generator` flag, but then our feed component would be required to call _next_ before _send_ just to execute coroutine up to the _yield_, so that it can be resumed with sent value. `Generator` flag can be set to false to eliminate such calls from user code, it automatically calls _next_ by itself, so caller does not need to bother and may start sending values right away. As the name of the flag indicates, you should not generate anything useful on the first call, as that value is effectively lost.

The second flag is `threadLocal` flag. This flag indicated that one `CoIterator` will be reused by many threads. Each thread then receives its own coroutine state and they can freely reuse coroutine without worrying about state inconsistencies.