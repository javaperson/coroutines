#summary This page describes how coroutines instrumentation layer works
#labels Featured

<wiki:toc max_depth="2" />

= Introduction =

Coroutines instrumentation uses excellent [http://asm.ow2.org/ ASM] library. 

Instrumentation is done in two phases. The first one is carried out to determine which methods in a class being loaded are marked as coroutines. It is fired for every loaded class if _runtime_ option is specified or for user specified classes only otherwise. It discovers instances of `Coroutine` annotation and marks which methods are annotated and need to be instrumented. It also performs basic sanity checks to see whether method is suitable to become coroutine: it must return `CoIterator` and not be abstract. If no such methods are found in the class there is no more work for the agent and it submits class unchanged to JVM runtime.
If any coroutine method is discovered the second phase begins. In this phase coroutine semantics are added to method(s) and `CoIterator` implementation(s) bound to coroutines are created.

= Coroutine methods =

All methods marked as coroutines in the previous phase are processed one by one. Processing starts with generating new public and final method which name is mangled original method name, so that no name collisions occur. The new method always returns an object and takes three formal arguments: `Frame` and two `Objects`. `mr.go.coroutines.core.Frame` is container in which coroutine execution state is hold (local variables value and operand stack contents) along with an integer saying where to jump on _next_/_send_ (it is -1 for closed coroutine, 0 for the first execution, 1 for the first _yield_ in method code, and so on). It also keeps names of local variables and line of code where recent yield took place for debugging purposes. To make use of this information your code has to be compiled with debug support and agent `debug` option needs to be turned on. 


At the beginning of every coroutine method *preamble* is generated. In pseudo-code:
{{{
int state = frame.getState(); 
Object[] locals = frame.getLocals();
if (chkclosed) throw closed;
switch(state)
{case 0: break; 
...
case n: goto yield;
default: throw invalid;
} 
arg1, arg2, arg3 = locals[i..j] 
if (chkexit) throw closed;
}}}

*Preamble* creates two additional local variables holding coroutine current state and an array of original local variables and their current values. Next, it checks whether state is equal to -1, if it is that means that coroutine have been closed and `CoroutineClosedException` is thrown. Then it finds an instruction where execution is suspended and jumps there unless `state == 0`. If state is 0 that means that this is the first execution of coroutine so there is really no _yield_ to jump to. In that case only local arguments passed to coroutine are restored and special check is generated which throws `CoroutineClosedException` if the caller closed this coroutine before it had a chance to execute.
Next all user code (bytecode) is emitted up to the yield point, except for return statements and the _ `_method` _. Returns are simply removed, `NoSuchElementException` is emitted instead, _ `_method` _ is replaced by no-op. All changes of variables positions caused by coroutine locals and arguments are taken into account. This procedure is repeated till the end of method instruction stream.

== Yielding ==

When call to `mr.go.coroutines.user.Coroutines.yield` is detected it is removed completely and replacement bytecode is emitted. Instructions which override `yield` store local variables and stack in the `Frame` container, update `Frame` state variable, resolve jump instruction offset from *preamble* _case_ statement, store the top element on the operand stack in the third local variable and emit jump instruction to *prologue* code. *Prologue* code's only task is to return reference from the third local variable, it is created after all user code instructions have been processed.

Because `Frame` must store every reference as an object reference


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages